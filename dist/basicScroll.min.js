(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.basicScroll = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = function parseUnit(str, out) {
    if (!out) out = [0, ''];

    str = String(str);
    var num = parseFloat(str, 10);
    out[0] = num;
    out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || '';
    return out;
};

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.create = undefined;

var _parseUnit = require('parse-unit');

var _parseUnit2 = _interopRequireDefault(_parseUnit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var instances = [];

/**
 * Returns all active instances from an array.
 * @param {Array} instances
 * @returns {Array} instances - Active instances.
 */
var getActiveInstances = function getActiveInstances(instances) {

	return instances.filter(function (instance) {
		return instance.isActive();
	});
};

/**
 * Returns the number of scrolled pixels.
 * @returns {Integer} scrollTop
 */
var getScrollTop = function getScrollTop() {

	// Use scrollTop because is's faster than getBoundingClientRect()
	return document.scrollingElement.scrollTop;
};

/**
 * Returns the height of the viewport.
 * @returns {Integer} viewportHeight
 */
var getViewportHeight = function getViewportHeight() {

	return window.innerHeight || window.outerHeight;
};

/**
 * Checks if a value is absolute.
 * An absolute value must have a value that's not NaN.
 * @param {String|Integer} value
 * @returns {Boolean} isAbsolute
 */
var isAbsoluteValue = function isAbsoluteValue(value) {

	return isNaN((0, _parseUnit2.default)(value)[0]) === true ? false : true;
};

/**
 * Parses an absolute value.
 * @param {String|Integer} value
 * @returns {Object} parsedValue
 */
var parseAbsoluteValue = function parseAbsoluteValue(value) {

	var parsedValue = (0, _parseUnit2.default)(value);

	return {
		value: parsedValue[0],
		unit: parsedValue[1]
	};
};

/**
 * Checks if a value is relative.
 * A relative value must start and end with [a-z] and needs a '-' in the middle.
 * @param {String|Integer} value
 * @returns {Boolean} isRelative
 */
var isRelativeValue = function isRelativeValue(value) {

	return String(value).match(/^[a-z]+-[a-z]+$/) === null ? false : true;
};

/**
 * Converts a relative value to an absolute value.
 * @param {String} value
 * @param {Node} elem - Anchor of the relative value.
 * @param {?Integer} scrollTop - Pixels scrolled in document.
 * @param {?Integer} viewportHeight - Height of the viewport.
 * @returns {String} absoluteValue
 */
var relativeToAbsoluteValue = function relativeToAbsoluteValue(value, elem) {
	var scrollTop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getScrollTop();
	var viewportHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getViewportHeight();


	var elemSize = elem.getBoundingClientRect();

	var elemAnchor = value.match(/^[a-z]+/)[0];
	var viewportAnchor = value.match(/[a-z]+$/)[0];

	var y = 0;

	if (viewportAnchor === 'top') y -= 0;
	if (viewportAnchor === 'middle') y -= viewportHeight / 2;
	if (viewportAnchor === 'bottom') y -= viewportHeight;

	if (elemAnchor === 'top') y += elemSize.top + scrollTop;
	if (elemAnchor === 'middle') y += elemSize.top + scrollTop + elemSize.height / 2;
	if (elemAnchor === 'bottom') y += elemSize.top + scrollTop + elemSize.height;

	return y + 'px';
};

/**
 * Validates options and sets defaults for undefined properties.
 * @param {?Object} opts
 * @returns {Object} opts - Validated options.
 */
var validate = function validate() {
	var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


	opts = Object.assign({}, opts);

	if (opts.from == null) throw new Error('Missing property `from`');
	if (opts.to == null) throw new Error('Missing property `to`');

	if (opts.elem == null) {

		if (isAbsoluteValue(opts.from) === false) throw new Error('Property `from` must be a absolute value when no `elem` has been provided');
		if (isAbsoluteValue(opts.to) === false) throw new Error('Property `to` must be a absolute value when no `elem` has been provided');
	} else {

		if (isRelativeValue(opts.from) === true) opts.from = relativeToAbsoluteValue(opts.from, opts.elem);
		if (isRelativeValue(opts.to) === true) opts.to = relativeToAbsoluteValue(opts.to, opts.elem);
	}

	opts.from = parseAbsoluteValue(opts.from);
	opts.to = parseAbsoluteValue(opts.to);

	forEachProp(opts.props, function (prop) {

		if (isAbsoluteValue(prop.from) === false) throw new Error('Property `from` of prop must be a absolute value');
		if (isAbsoluteValue(prop.to) === false) throw new Error('Property `from` of prop must be a absolute value');

		prop.from = parseAbsoluteValue(prop.from);
		prop.to = parseAbsoluteValue(prop.to);
	});

	return opts;
};

/**
 * Updates instance props and their values.
 * @param {Object} opts
 * @param {?Integer} scrollTop - Pixels scrolled in document.
 * @returns {Array} props - Updated props.
 */
var update = function update(opts) {
	var scrollTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getScrollTop();


	// 100% in pixel
	var total = opts.to.value - opts.from.value;

	// Pixel already scrolled
	var current = scrollTop - opts.from.value;

	// Percent already scrolled
	var percentage = current / (total / 100);

	// Normalize percentage
	if (percentage <= 0) percentage = 0;
	if (percentage > 100) percentage = 100;

	var values = [];

	// Update each value
	forEachProp(opts.props, function (prop, key) {

		var diff = prop.from.value - prop.to.value;
		var unit = prop.from.unit || prop.to.unit;

		values.push({
			key: key,
			value: prop.from.value - diff / 100 * percentage + unit
		});
	});

	return values;
};

/**
 * Executes a function for each prop in props.
 * @param {Object} props - Object with props as properties.
 * @param {Function} fn - Function to execute.
 */
var forEachProp = function forEachProp(props, fn) {

	for (var key in props) {
		fn(props[key], key, props);
	}
};

/**
 * Adds a property with the specified name and value to a given style object.
 * @param {Object} style - Style object.
 * @param {Object} prop - Object with a key and value.
 */
var setProp = function setProp(style, prop) {

	style.setProperty(prop.key, prop.value);
};

/**
 * Gets and sets new props when the user has scrolled and when there are active instances.
 * This part get executed with every frame. Make sure it's performant as hell.
 * @param {Object} style - Style object.
 * @param {?Integer} previousScrollTop
 */
var loop = function loop(style, previousScrollTop) {

	// Continue loop
	var repeat = function repeat() {

		// It depends on the browser, but it turns out that closures
		// are sometimes faster than .bind or .apply.
		requestAnimationFrame(function () {
			return loop(style, previousScrollTop);
		});
	};

	// Get all active instances
	var activeInstances = getActiveInstances(instances);

	// Only continue when active instances available
	if (activeInstances.length === 0) return repeat();

	var scrollTop = getScrollTop();

	// Only continue when scrollTop has changed
	if (previousScrollTop === scrollTop) return repeat();else previousScrollTop = scrollTop;

	// Get new props of each instance
	var newProps = activeInstances.map(function (instance) {
		return instance.update(scrollTop);
	});

	// Flatten props because each update can return multiple props.
	// The second parameter of contact takes an array, so the line is identical to:
	// [].concat(['1'], ['2'], ['3'])
	var flattedProps = [].concat.apply([], newProps);

	// Set new props
	flattedProps.forEach(function (prop) {
		return setProp(style, prop);
	});

	repeat();
};

/**
 * Creats a new instance.
 * @param {Object} opts
 * @returns {Object} instance
 */
var create = exports.create = function create(opts) {

	// Validate options
	opts = validate(opts);

	// Store if instance is started or stopped
	var active = false;

	// Returns if instance is started or stopped
	var _isActive = function _isActive() {

		return active;
	};

	// Update props
	var _update = function _update(scrollTop) {

		return update(opts, scrollTop);
	};

	// Starts to animate
	var _start = function _start() {

		active = true;
	};

	// Stops to animate
	var _stop = function _stop() {

		active = false;
	};

	// Assign instance to a variable so the instance can be used
	// elsewhere in the current function
	var instance = {
		isActive: _isActive,
		update: _update,
		start: _start,
		stop: _stop
	};

	// Store instance in global array
	instances.push(instance);

	return instance;
};

// Start to loop
loop(document.documentElement.style);

},{"parse-unit":1}]},{},[2])(2)
});